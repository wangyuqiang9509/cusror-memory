# 创建日志：系统化调试技能

提取、结构化和强化关键技能的参考示例。

## 源材料

从 `/Users/jesse/.claude/CLAUDE.md` 提取的调试框架：
- 4 阶段系统化流程（调查 → 模式分析 → 假设 → 实现）
- 核心原则：始终找到根本原因，永不修复症状
- 设计规则以抵抗时间压力和合理化

## 提取决策

**包含内容：**
- 完整的 4 阶段框架及所有规则
- 反捷径（"永不修复症状"，"停止并重新分析"）
- 抗压力语言（"即使更快"，"即使我看起来很匆忙"）
- 每个阶段的具体步骤

**排除内容：**
- 项目特定上下文
- 同一规则的重复变体
- 叙述性解释（压缩为原则）

## 遵循 skill-creation/SKILL.md 的结构

1. **丰富的 when_to_use** - 包含症状和反模式
2. **类型：技术** - 带步骤的具体流程
3. **关键词** - "根本原因"，"症状"，"变通方法"，"调试"，"调查"
4. **流程图** - "修复失败"的决策点 → 重新分析 vs 添加更多修复
5. **阶段分解** - 可扫描的检查清单格式
6. **反模式部分** - 不该做什么（对这个技能至关重要）

## 强化元素

设计框架以抵抗压力下的合理化：

### 语言选择
- "始终" / "永不"（不是"应该" / "尝试"）
- "即使更快" / "即使我看起来很匆忙"
- "停止并重新分析"（明确的暂停）
- "不要跳过"（捕获实际行为）

### 结构防御
- **第一阶段必需** - 不能跳到实现
- **单一假设规则** - 强制思考，防止散弹枪式修复
- **明确的失败模式** - "如果你的第一次修复不起作用"有强制性动作
- **反模式部分** - 展示捷径看起来是什么样子

### 冗余
- 根本原因命令在概述 + when_to_use + 第一阶段 + 实现规则中
- "永不修复症状"在不同上下文中出现 4 次
- 每个阶段都有明确的"不要跳过"指导

## 测试方法

按照 skills/meta/testing-skills-with-subagents 创建了 4 个验证测试：

### 测试 1：学术环境（无压力）
- 简单 bug，无时间压力
- **结果：** 完美遵守，完整调查

### 测试 2：时间压力 + 明显的快速修复
- 用户"很匆忙"，症状修复看起来很容易
- **结果：** 抵抗了捷径，遵循完整流程，找到了真正的根本原因

### 测试 3：复杂系统 + 不确定性
- 多层失败，不清楚是否能找到根本原因
- **结果：** 系统调查，追踪所有层，找到源头

### 测试 4：第一次修复失败
- 假设不起作用，诱惑添加更多修复
- **结果：** 停止，重新分析，形成新假设（没有散弹枪式修复）

**所有测试通过。** 没有发现合理化。

## 迭代

### 初始版本
- 完整的 4 阶段框架
- 反模式部分
- "修复失败"决策的流程图

### 增强 1：TDD 参考
- 添加了 skills/testing/test-driven-development 的链接
- 解释 TDD 的"最简单代码" ≠ 调试的"根本原因"的说明
- 防止方法论之间的混淆

## 最终结果

强化的技能：
- ✅ 清楚地要求根本原因调查
- ✅ 抵抗时间压力的合理化
- ✅ 为每个阶段提供具体步骤
- ✅ 明确展示反模式
- ✅ 在多种压力场景下测试
- ✅ 阐明与 TDD 的关系
- ✅ 可以使用

## 关键洞察

**最重要的强化：** 反模式部分展示在那一刻感觉合理的确切捷径。当 Claude 想"我只是添加这一个快速修复"时，看到这个确切的模式被列为错误会产生认知摩擦。

## 使用示例

遇到 bug 时：
1. 加载技能：skills/debugging/systematic-debugging
2. 阅读概述（10 秒）- 提醒命令
3. 遵循第一阶段检查清单 - 强制调查
4. 如果想跳过 - 看到反模式，停止
5. 完成所有阶段 - 找到根本原因

**时间投入：** 5-10 分钟
**节省时间：** 数小时的症状打地鼠

---

*创建时间：2025-10-03*
*目的：技能提取和强化的参考示例*
